'use strict'

/**
 * PBKDF2 Utility methods
 *
 * @see https://gist.github.com/skeggse/52672ddee97c8efec269
 */

const crypto = require('crypto')

// Number of PBKDF2 iterations used for new passwords
//
// Since the iteration count is stored in the password hash it is safe to
// increase this over time. Existing passwords can be refreshed on login by
// calling hashPassword again.
//
// 1024 iterations is chosen to take about 2-5 ms on hardware you might commonly
// find in a server deployment. Users who need more security or more performance
// are encouraged to pass a different value via the second parameter in
// hashPassword.
const PBKDF2_ITERATIONS = 1024

// Number of iterations used during unit tests
const PBKDF2_ITERATIONS_TEST = 5

// Hash algorithm to use
//
// Warning: The hash algorithm is NOT stored in the combined hash, so it is NOT
// safe to change without further consideration.
const PBKDF2_DIGEST = 'sha512'

// Size of the salt
//
// 128 bits is enough to ensure that the chance of reusing the same salt is
// negligible.
const PBKDF2_SALT_BYTES = 128 / 8

// Size of the output password hash in PBKDF2
//
// 128 bits is enough to make brute force attacks (guessing passwords)
// impractical, even if the password hash is known to the attacker.
const PBKDF2_HASH_BYTES = 128 / 8

/**
 * Hash a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Returns a self-contained buffer which can be arbitrarily encoded for storage
 * that contains all the data needed to verify a password.
 *
 * @param {!String} password
 * @return {Promise<Buffer>} Generated hash (with encoded salt and iterations)
 */
function hashPassword (password, customIterations) {
  const iterations = (process.env.NODE_ENV !== 'unit')
    ? customIterations || PBKDF2_ITERATIONS
    : PBKDF2_ITERATIONS_TEST

  if (typeof password === 'string') {
    password = Buffer.from(password, 'utf8')
  }

  return new Promise((resolve, reject) => {
    // Generate a salt for pbkdf2
    crypto.randomBytes(PBKDF2_SALT_BYTES, (err, salt) => {
      if (err) {
        return reject(err)
      }

      try {
        crypto.pbkdf2(
          password,
          salt,
          iterations,
          PBKDF2_HASH_BYTES,
          PBKDF2_DIGEST,
          (err, hash) => {
            if (err) {
              return reject(err)
            }

            var combined = Buffer.alloc(hash.length + salt.length + 8)

            // Include the size of the salt so that we can, during verification,
            // figure out how much of the hash is salt
            combined.writeUInt32BE(salt.length, 0, true)

            // Similarly, include the iteration count
            combined.writeUInt32BE(iterations, 4, true)

            salt.copy(combined, 8)
            hash.copy(combined, salt.length + 8)

            resolve(combined)
          }
        )
      } catch (err) {
        reject(err)
      }
    })
  })
}

/**
 * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Accepts a hash and salt generated by hashPassword, and returns whether the
 * hash matched the password (as a boolean).
 *
 * @param {!String} password
 * @param {!Buffer} combined Buffer containing hash and salt as generated by
 *   hashPassword.
 * @return {Promise<Boolean>} Whether the password matched the hash
 */
function verifyPassword (password, combined) {
  // Extract the salt and hash from the combined buffer
  const saltBytes = combined.readUInt32BE(0)
  const hashBytes = combined.length - saltBytes - 8
  const iterations = combined.readUInt32BE(4)
  const salt = combined.slice(8, saltBytes + 8)
  const hash = combined.slice(saltBytes + 8)

  return new Promise((resolve, reject) => {
    // Verify the salt and hash against the password
    crypto.pbkdf2(password, salt, iterations, hashBytes, PBKDF2_DIGEST, (err, verify) => {
      if (err) {
        return reject(err)
      }

      resolve(verify.equals(hash))
    })
  })
}

module.exports = hashPassword
hashPassword.verifyPassword = verifyPassword
